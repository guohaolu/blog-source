Redis为什么虽然是单线程，性能仍比Memcached好？

Redis虽然是单线程模型，但性能仍然优于多线程的Memcached，主要有以下几个原因：

1. **内存模型不同**
- Redis直接自己构建了VM机制，减少内存碎片和申请/释放内存的开销
- Memcached使用预分配的内存池，需要进行内存申请和释放，产生内存碎片

2. **网络模型不同**([1](https://redis.io/docs/))
- Redis使用自己实现的事件驱动库AE，采用多路复用技术(epoll)
- Memcached是基于libevent构建的多线程模型，线程之间需要锁竞争

3. **数据结构不同**
- Redis有丰富的数据结构(String、Hash、List、Set、ZSet等)，数据操作更高效
- Memcached只支持简单的key-value结构，复杂操作需要客户端实现

4. **持久化机制**
- Redis支持RDB和AOF两种持久化方式，可以定期将数据同步到磁盘
- Memcached数据只在内存中，重启后数据会丢失

5. **单线程的优势**
- 避免了多线程的上下文切换开销
- 避免了多线程的锁竞争问题
- 简化了数据结构和算法的实现
- 保证了数据访问的原子性，不需要额外的同步机制

6. **I/O多路复用**
- Redis使用epoll/kqueue等I/O多路复用技术
- 单线程可以处理大量的并发连接
- 非阻塞I/O，提高了I/O效率

总的来说，Redis通过巧妙的设计(高效的数据结构、I/O多路复用、内存管理等)，充分发挥了单线程的优势，同时规避了多线程带来的问题，因此可以实现比Memcached更好的性能。

---------------------------------------------------------------------------------

Redis的数据类型和底层数据结构是什么？

Redis中的数据类型和数据结构是两个不同的概念：

### 一、数据类型（对外使用的数据类型）

1. **基本数据类型**([1](https://redis.io/docs/))
- **String（字符串）**：最基本的数据类型，可以存储字符串、整数或浮点数，最大512MB
- **List（列表）**：按插入顺序排序的字符串列表，支持双向操作，可用于消息队列
- **Hash（哈希）**：键值对的无序散列表，适合存储对象
- **Set（集合）**：无序的字符串集合，自动去重，支持并交差集运算
- **Zset（有序集合）**：有序的字符串集合，每个元素关联一个分数，可按分数排序

2. **特殊数据类型**
- **Bitmap（位图）**：二进制位操作，适合统计日活、在线状态等布尔型数据
- **HyperLogLog**：基数统计，统计UV等，占用空间小，有一定误差
- **GEO（地理位置）**：存储地理坐标，支持计算距离、范围查询等

### 二、底层数据结构（内部实现）

1. **简单动态字符串(SDS)**
- 用于实现String类型
- 相比C字符串，增加了长度字段，避免了多次遍历
- 预分配空间，减少内存分配次数

2. **双向链表(linkedlist)**
- 用于实现List类型
- 带有前驱和后继指针
- 支持双向遍历

3. **压缩列表(ziplist)**
- 用于优化存储空间
- 可用于实现List、Hash、Zset等
- 适用于元素数量少、元素值小的场景

4. **哈希表(hashtable)**
- 用于实现Hash、Set等
- 使用MurmurHash2算法计算哈希值
- 采用链地址法解决冲突

5. **跳表(skiplist)**
- 主要用于实现Zset
- 平均O(logN)的查找复杂度
- 相比红黑树，实现更简单，内存占用更小

6. **整数集合(intset)**
- 用于优化Set的整数存储
- 随数据升级编码方式
- 节省内存空间

7. **QuickList**
- Redis 3.2后用于实现List
- 结合了ziplist和linkedlist的优点
- 平衡了存储效率和访问效率

### 三、数据类型与数据结构的关系

1. **String类型**
- 整数：直接存储
- 短字符串(≤44字节)：嵌入式存储
- 长字符串：SDS存储

2. **List类型**
- 3.2版本前：ziplist或linkedlist
- 3.2版本后：quicklist

3. **Hash类型**
- 小规模数据：ziplist
- 大规模数据：hashtable

4. **Set类型**
- 整数集合：intset
- 其他情况：hashtable

5. **Zset类型**
- 小规模数据：ziplist
- 大规模数据：skiplist+hashtable

这种分层设计体现了Redis的优化思想：在不同场景下选择最优的数据结构，在性能和内存使用之间取得平衡。

---------------------------------------------------------------------------------

### Redis SDS预分配空间机制

Redis的SDS通过预分配空间来减少内存分配的次数，具体策略如下：

1. **预分配规则**
- 当字符串长度小于1MB时，扩容会分配双倍空间
  - 例如：修改后长度为13字节，则会分配13+13=26字节
- 当字符串长度大于等于1MB时，扩容会多分配1MB空间
  - 例如：修改后长度为30MB，则会分配30MB+1MB=31MB

2. **优势说明**
- 减少内存重新分配次数
  - 传统C字符串每次增长都需要重新分配内存
  - SDS预分配策略让连续增长可以重用之前预留的空间
- 降低内存操作开销
  - 减少了malloc、realloc、free等系统调用
  - 避免了频繁的数据复制和移动

3. **举例说明**
假设字符串从空开始，依次追加5次，每次1个字节：
- 传统C字符串：需要5次内存分配
- Redis SDS：
  - 第1次：分配1+1=2字节
  - 第2次：使用预分配空间，无需分配
  - 第3次：使用预分配空间，无需分配
  - 第4次：分配4+4=8字节
  - 第5次：使用预分配空间，无需分配
  最终只需要2次内存分配

---------------------------------------------------------------------------------

操作系统默认的page cache大小是多少？

1. **Page Size大小**
- Linux默认页大小为4KB (4096字节)
- 可以通过命令查看：`getconf PAGE_SIZE`
- 某些系统支持大页(Huge Page)，如2MB或1GB

2. **Page Cache总大小**
- 不是固定值，是动态调节的
- 默认最大可使用所有可用物理内存
- Linux通过vm.swappiness参数调节内存与swap的权衡
- 通过/proc/sys/vm/drop_caches手动释放

3. **查看方式**
```bash
# 查看当前page cache使用情况
cat /proc/meminfo | grep -i cache

# 查看系统页大小
getconf PAGE_SIZE
```

4. **影响因素**
- 系统总内存大小
- 当前内存使用压力
- 系统IO负载情况
- 内核参数配置

---------------------------------------------------------------------------------

Kafka中的ISR和OSR是什么？

1. **ISR (In-Sync Replicas)**
- 含义：与Leader保持同步的副本集合
- 判定标准：
  - 与Leader保持连接状态
  - 延迟不超过replica.lag.time.max.ms(默认10秒)
  - 消息复制进度不落后太多
- 作用：
  - 参与Leader选举
  - 保证数据可靠性
  - 维护数据一致性

2. **OSR (Out-of-Sync Replicas)**
- 含义：与Leader失去同步的副本集合
- 产生原因：
  - 副本所在Broker宕机
  - 网络延迟过高
  - 副本复制速度跟不上Leader
- 特点：
  - 不参与Leader选举
  - 持续从Leader同步数据
  - 追上进度后可重新加入ISR

3. **工作机制**
- AR(Assigned Replicas) = ISR + OSR
- 副本动态在ISR和OSR间转换
- Leader只等待ISR中的副本完成同步
- 新Leader只从ISR中选举产生

4. **应用场景**
- 数据可靠性保证
- 故障恢复处理
- 集群弹性伸缩

---------------------------------------------------------------------------------

Kafka的消费者是线程安全的吗？

Kafka的消费者（KafkaConsumer）不是线程安全的，具体表现在：

1. **官方说明**([1](https://kafka.apache.org/documentation/))
- KafkaConsumer不是线程安全的
- 所有网络I/O操作都发生在进行调用的线程中
- 可以安全地关闭消费者或者从另一个线程唤醒轮询

2. **正确使用方式**
- 单线程消费：一个消费者实例对应一个线程
- 多线程处理：消费单线程，处理多线程
- 多消费者实例：每个线程一个独立的消费者实例

3. **错误使用示例**
```java
// 错误示例：多线程共享一个消费者实例
KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
ExecutorService executor = Executors.newFixedThreadPool(2);
executor.submit(() -> consumer.poll(Duration.ofMillis(100)));  // 线程1
executor.submit(() -> consumer.poll(Duration.ofMillis(100)));  // 线程2
```

4. **正确使用示例**
```java
// 正确示例1：每个线程一个消费者实例
ExecutorService executor = Executors.newFixedThreadPool(2);
executor.submit(() -> {
    KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
    while (true) {
        ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
        // 处理消息
    }
});

// 正确示例2：消费单线程，处理多线程
KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
ExecutorService executor = Executors.newFixedThreadPool(2);
while (true) {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        executor.submit(() -> processRecord(record));  // 异步处理
    }
}
```

5. **最佳实践建议**
- 使用消费者组机制实现并行消费
- 处理逻辑放入线程池异步执行
- 注意消费位移的正确提交
- 合理设置消费者数量和分区数

---------------------------------------------------------------------------------

Kafka的Rebalance再均衡策略是什么？

1. **什么是Rebalance**([1](https://kafka.apache.org/documentation/))
- 当消费者组成员发生变化时触发的分区重新分配机制
- 目的是实现负载均衡，让分区尽可能均匀地分配给所有消费者

2. **触发条件**
- 消费者组成员数量发生变化（新增或减少消费者）
- 订阅的主题数量发生变化
- 主题的分区数发生变化
- 消费者宕机或网络故障

3. **再均衡策略**
- **Range策略（默认）**
  - 按照分区号范围进行分配
  - 可能会导致分配不均
  - 分配公式：分区号/消费者数量
  
- **RoundRobin策略**
  - 轮询分配方式
  - 分区分配更均匀
  - 适合分区数较多的场景

- **Sticky策略**
  - 分配尽可能与上次保持相同
  - 减少分区迁移带来的开销
  - 在出现故障时才进行必要的分区移动

4. **再均衡过程**
- 消费者组选举Group Coordinator
- Group Coordinator选举Leader Consumer
- Leader制定分配方案
- Group Coordinator将方案下发给所有消费者

5. **注意事项**
- 再均衡期间消费者无法消费消息
- 频繁的再均衡会影响系统性能
- 合理设置session.timeout.ms和heartbeat.interval.ms
- 建议使用Sticky策略减少不必要的分区移动

---------------------------------------------------------------------------------

